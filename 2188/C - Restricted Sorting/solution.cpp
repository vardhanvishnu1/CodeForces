#include <iostream>#include <vector>#include <algorithm> using namespace std; /** * Problem Summary: * Find max k such that array 'a' can be sorted by swapping a[i], a[j]  * if |a[i] - a[j]| >= k. */ void solve() {    int n;    if (!(cin >> n)) return;     vector<int> a(n);    for (int i = 0; i < n; ++i) {        cin >> a[i];    }     // b is the target sorted version of a    vector<int> b = a;    sort(b.begin(), b.end());     // If already sorted, the problem implies k can be arbitrarily large,    // but the standard competitive programming interpretation for this specific     // problem type is to output -1.    if (a == b) {        cout << -1 << "\n";        return;    }     int b_min = b[0];    int b_max = b[n - 1];    int ans = 2e9; // Initialize with a large value (infinity)     for (int i = 0; i < n; ++i) {        // We only care about elements that actually need to move        if (a[i] != b[i]) {            // For a[i] to be 'movable', k must be <= max(|a[i]-min|, |a[i]-max|)            int max_reachable_gap = max(abs(a[i] - b_min), abs(a[i] - b_max));                        // k must satisfy this for ALL out-of-place elements,             // so we take the minimum of these gaps.            ans = min(ans, max_reachable_gap);        }    }     cout << ans << "\n";} int main() {    // Speed up I/O for large test cases    ios_base::sync_with_stdio(false);    cin.tie(NULL);     int t;    cin >> t;    while (t--) {        solve();    }    return 0;}