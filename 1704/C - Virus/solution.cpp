#include <iostream>#include <vector>#include <algorithm> using namespace std; // Defining the structure used in your snippetstruct str {    long long x; // Size of the gap    int type;    // Placeholder for type logic}; void solve() {    int n, m;    // n = total length/elements, m = number of occupied spots    if (!(cin >> n >> m)) return;     vector<long long> a(m + 1);    for (int i = 1; i <= m; ++i) {        cin >> a[i];    }     // 1. Sort the initial occupied positions    sort(a.begin() + 1, a.end());     vector<str> t(m + 1);    int k = 0;     // 2. Calculate gaps between consecutive occupied spots    for (int i = 2; i <= m; ++i) {        t[++k] = { a[i] - a[i - 1] - 1, 2 };    }     // 3. Calculate the "wrap-around" gap (for circular problems)    int num_tmp_gap = a[1] + n - a[m] - 1;    if (num_tmp_gap > 0) {        t[++k] = { (long long)num_tmp_gap, 2 };    }     // 4. Sort gaps in descending order to prioritize saving the largest areas    sort(t.begin() + 1, t.begin() + k + 1, [](str a, str b) {        return a.x > b.x;    });     long long ans = 0; // Number of elements saved    long long cnt = 0; // Time penalty (spread)     // 5. Greedy approach to pick the best gaps    for (int i = 1; i <= k; ++i) {        long long current_gap = t[i].x - cnt * 2;        if (current_gap > 0) {            // If the gap is 1, we can only save 1 element before it's gone            // If the gap > 1, we save (gap - 1) because the last spot is lost while locking it            long long saved = max(1LL, current_gap - 1);            ans += saved;        }        cnt += 2; // Each gap processed takes 2 units of time (2 turns)    }     // Output the total elements minus those saved (the "infected" or "lost" ones)    printf("%lld\n", n - ans);} int main() {    // Standard competitive programming setup    int t;    if (cin >> t) {        while (t--) {            solve();        }    }    return 0;}